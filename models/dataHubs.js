/*
 * dataHubs.js
 */

const CSV = require('csv-string')

const k = require('../constants')

module.exports = {
    generateDatasets
  , generateSamplesCSV
  , merge
  , filter
  , getValues
  , getKeyValues
  , getTracksAsText
  , getTracksAsJSON
  , getTracksAsExtendedJSON
  , forEachTrack
  , forEachDataset
}

/**
 * Generate getGridJSON output from datahub
 * @param {object} dataHub - IHEC data hub
 * @param {object} context
 * @param {object} context.source - source of the data
 * @param {object} context.institutions - institutions ID by name/short_name
 * @param {object} context.species - species name by taxon ID
 */
function generateDatasets(dataHub, context = {}) {
  const hubDescription = dataHub.hub_description
  const datasetsByID = dataHub.datasets
  const samplesByID  = dataHub.samples

  const datasets = []

  Object.entries(datasetsByID).forEach(([id, props]) => {

    const sample = samplesByID[props.sample_id]

    if (!sample)
      throw new Error(`Sample not found for dataset ${id}: ${JSON.stringify(props)}`)

    const ihecData = props.ihec_data_portal

    const assay = ihecData ? ihecData.assay : props.experiment_attributes.experiment_type
    const cellType = ihecData ? ihecData.cell_type : sample.cell_type
    const institution = ihecData ?
        context.institutions[ihecData.publishing_group]
      : context.institutions[hubDescription.publishing_group]
    const epirrID = props.experiment_attributes.reference_registry_id
    const species = context.species[hubDescription.taxon_id] || hubDescription.taxon_id

    // MUST be in the same order as k.GRID_RECORD_KEYS
    const dataset = [
        /* id:          */ id
      , /* sampleID:    */ props.sample_id
      , /* assay:       */ assay || k.DEFAULT_ASSAY
      , /* cell_type:   */ cellType || k.DEFAULT_CELL_TYPE
      , /* donorID:     */ sample.donor_id || null
      , /* epirr_id:    */ epirrID || null
      , /* institution: */ institution || k.DEFAULT_INSTITUTION_ID
      , /* species:     */ species || null
      , /* source:      */ context.source
      , /* datasetID:   */ ihecData ? ihecData.id : null // Need db's dataset.id for correlations
    ]

    datasets.push(dataset)
  })

  return datasets
}

/**
 * Generate CSV of samples
 * @param {object} datahub - IHEC data hub
 * @returns {string} CSV content
 */
function generateSamplesCSV(datahub) {
  const headersSet = new Set()

  Object.values(datahub.samples).forEach(s => {
    Object.keys(s).forEach(k => headersSet.add(k))
  })

  const headers = Array.from(headersSet)
  const data = [['id'].concat(headers)]

  Object.keys(datahub.samples).forEach(id => {
    const sample = datahub.samples[id]
    data.push([id].concat(headers.map(h => sample[h])))
  })

  return CSV.stringify(data)
}

/**
 * Merges multiple datahubs
 * @param {Array<object>} hubs - Array of hubs, where a hub is { data: <IHEC Data Hub>, context: {...}}
 */
function merge(hubs) {
  if (hubs.length === 1)
    return hubs[0].data

  const result = {
    datasets: {},
    samples: {},
    hub_description: {
      taxon_id: hubs[0].data.hub_description.taxon_id,
      assembly: hubs[0].data.hub_description.assembly,
      email: 'info@epigenomesportal.ca',
      date: new Date().toISOString().match(/[^T]+/)[0],
      description:
        'Data hub generated by the IHEC Data Portal, with the following parameters: '
        + JSON.stringify(hubs[0].context.params),
      publishing_group: 'Other',
      releasing_group: 'Other',
    }
  }

  hubs.forEach(hub => {
    Object.entries(hub.data.datasets).forEach(([id, value]) => {
      result.datasets[id] = value
    })
    Object.entries(hub.data.samples).forEach(([id, value]) => {
      result.samples[id] = value
    })
  })

  return result
}

/** Filters @dataHub according to @predicate */
function filter(dataHub, predicate) {
  const originalDatasets = dataHub.datasets
  const originalSamples  = dataHub.samples

  // Generate queryable objects
  const qs = toList(originalDatasets).map(d => ({
    ...(d.ihec_data_portal || {}),
    ...d.analysis_attributes,
    ...d.experiment_attributes,
    ...originalSamples[d.sample_id],
    id: d.id,
    sample_id: d.sample_id,
  }))

  const samplesID = new Set()
  const datasetsID = new Set()

  qs.forEach(item => {
    if (predicate(item)) {
      datasetsID.add(item.id)
      samplesID.add(item.sample_id)
    }
  })

  const result = {
    datasets: {},
    samples: {},
    hub_description: { ...dataHub.hub_description }
  }

  Object.keys(originalDatasets).forEach(id => {
    if (datasetsID.has(id))
      result.datasets[id] = originalDatasets[id]
  })

  Object.keys(originalSamples).forEach(id => {
    if (samplesID.has(id))
      result.samples[id] = originalSamples[id]
  })

  return result
}

/** Returns a function that will get distinct values of @key for @hubs */
function getValues(key) {
  return function(hubs) {
    const values = new Set()

    hubs.forEach(hub => {

      const datasets  = hub.data.datasets
      const samples  = hub.data.samples

      toList(datasets).forEach(d => {
        const item = {
          ...(d.ihec_data_portal || {}),
          ...d.analysis_attributes,
          ...d.experiment_attributes,
          ...samples[d.sample_id],
          id: d.id,
          sample_id: d.sample_id,
        }

        values.add(item[key])
      })
    })

    return Array.from(values)
  }
}

/** Returns a function that will get distinct key-values of @term for @hubs */
function getKeyValues(term) {
  return function(hubs) {
    const lowerTerm = term.toLowerCase()
    const keyValues = new Set()

    hubs.forEach(hub => {

      const datasets  = hub.data.datasets
      const samples  = hub.data.samples

      toList(datasets).forEach(d => {
        const item = {
          ...(d.ihec_data_portal || {}),
          ...d.analysis_attributes,
          ...d.experiment_attributes,
          ...samples[d.sample_id],
          id: d.id,
          sample_id: d.sample_id,
        }

        Object.keys(item).forEach(key => {
          const value = String(item[key])

          if (value.toLowerCase().includes(lowerTerm))
            keyValues.add(`${key}:::::${value}`)
        })
      })
    })

    return Array.from(keyValues).map(s => s.split(':::::'))
  }
}

/** Returns the tracks for download */
function getTracksAsText(hubs) {
  const result = []

  forEachTrack(hubs, (track) =>
    result.push(track.big_data_url))

  return result.join('\n')
}

/** Returns the tracks for download */
function getTracksAsJSON(hubs) {
  const result = []

  forEachTrack(hubs, (track, type, dataset, id, sample, hub) =>
    result.push({
      url: track.big_data_url,
      assembly: hub.data.hub_description.assembly || null,
      institution:
        dataset.ihec_data_portal && dataset.ihec_data_portal.publishing_group ||
        hub.data.hub_description.publishing_group || null,
      cellTypeCategory: dataset.ihec_data_portal && dataset.ihec_data_portal.cell_type_category || 'Unkown',
      rawDataURL: dataset.ihec_data_portal && dataset.ihec_data_portal.raw_data_url || null,
      source: hub.context.source,
      isExternal: hub.context.isExternal,
      build: hub.context.build || null,
    }))

  return result
}

/** Returns the tracks for download */
function getTracksAsExtendedJSON(hubs) {
  const result = []

  forEachTrack(hubs, (track, type, dataset, id, sample, hub) =>
    result.push({
      id,
      type,
      url: track.big_data_url,
      assembly: hub.data.hub_description.assembly || null,
      institution:
        dataset.ihec_data_portal && dataset.ihec_data_portal.publishing_group ||
        hub.data.hub_description.publishing_group || null,
      cellTypeCategory: dataset.ihec_data_portal && dataset.ihec_data_portal.cell_type_category || 'Unkown',
      rawDataURL: dataset.ihec_data_portal && dataset.ihec_data_portal.raw_data_url || null,
      source: hub.context.source,
      isExternal: hub.context.isExternal,
      build: hub.context.build || null,
      sampleID: dataset.sample_id,
    }))

  return result
}

// Helpers

function forEachTrack(hubs, fn) {
  let i = 0
  asArray(hubs).forEach(hub => {
    Object.keys(hub.data.datasets).forEach(id => {
      const dataset = hub.data.datasets[id]
      const sample = hub.data.samples[dataset.sample_id]
      Object.keys(dataset.browser).forEach(type => {
        const tracks = dataset.browser[type]
        tracks.forEach(track => {
          fn(track, type, dataset, id, sample, hub, i++)
        })
      })
    })
  })
}

function forEachDataset(hubs, fn) {
  asArray(hubs).forEach(hub => {
    Object.keys(hub.data.datasets).forEach(id => {
      const dataset = hub.data.datasets[id]
      const sample = hub.data.samples[dataset.sample_id]
      fn(dataset, id, sample, hub)
    })
  })
}

function asArray(value) {
  return Array.isArray(value) ? value : [value]
}

function toList(byID) {
  return Object.keys(byID).reduce((acc, id) => {
    acc.push({ ...byID[id], id: id })
    return acc
  }, [])
}
